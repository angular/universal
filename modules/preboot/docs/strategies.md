#Strategies

The idea behind a strategy in the preboot library is to allow the developer to customize the library to
suit their needs. There are typically a couple built-in options for each type of strategy, but the developer
can always write their own. The client-side code generated by preboot will only contain the strategies
that are actually being used. So, in other words, if you don't specify 'attributes' as a listen strategy
in the preboot options, then none of the list_by_attributes.js code will be incldued in the generated
client-side code.

## Listen Strategies

The 'listen' option can either be a string (the name of the pre-built strategy), configuration object (see below)
or an array of configuration objects.

Each configuration object must have one of two values:

* `name` - The name of the strategy (see below)
* `getNodeEvents` - A custom strategy implementation ([see example](examples.md#listen-strategy))

The pre-built strategy or the custom getNodeEvents will return an array of these objects:

```
{
    node: node,  // the DOM element that is being tracked
    eventName: eventName  // the name of the event to watch out for on that element
}
```

The other options for the configuration object work off of these returned event objects.

* `preventDefault` - Stop even propagation
* `dispatchEvent` - The name of an custom event that should be dispatched when event occurs
* `trackFocus` - Track current focus if on the target node
* `doNotReplay` - No not replay these events
* `attributeName` - Only used by the attributes strategy to identify the name of the attribute that will have
all the events that need to be recorded (default value is 'preboot-events')
* `eventsBySelector` - This is only used by the selectors strategy. It should be an object that maps a selector
string to an array of events.
* `action` - Custom function executed when events occur ([see example](examples.md#listen-strategy))

The pre-built listen strategies are:
 
1. **attributes** - This strategy will inspect the server view for any element that contains a particular attribute
name (default is 'preboot-events'). So if there is a `<input preboot-events="keypress,focus">` then all keypress
and focus events on that input element would be tracked.
1. **event_bindings** - This strategy is only useful with Angular 2. It walks the DOM to loop for event bindings 
(i.e. anything with ()="" or on-*=""). This is useful for play, but likely shouldn't be used for real since
it can be slow (i.e. walking the DOM), doesn't allow configuration for different types of events and it
doesn't track Angular events defined within a component definition (i.e. not in the template).
1. **selectors** - This strategy requires the use of the eventsBySelector option (see [options section](#options) above).
You basically specify a selector and the events you want for those nodes. For example:
`{ 'input[type="text"],button': ['keypress', 'keydown', 'keyup'] }`

## Replay Strategies

The 'replay' option can either be a string (the name of the pre-built strategy), configuration object (see below)
or an array of configuration objects.

Each configuration object must have one of two values:

* `name` - The name of the strategy (see below)
* `replayEvents` - A custom strategy implementation ([see example](examples.md#replay-strategy))

The pre-built strategy or custom replayEvents implementation will attempt to replay all events passed in.
If, however, any events can't be replayed for any reason, they can be returned in an array. If there is
an array of replay strategies defined for preboot, the remaining events from one replay strategy will be
feed into the next.

The pre-built replay strategies are:
 
1. **hydrate** - This assumes that the server view and the client view are the same. In other words,
the DOM elements in memory for the server view are still there with the client view. So, when replaying
events, we can simply use the existing nodes in memory. Easy peasy.
1. **rerender** - During a re-render, the client view typically blows the server view away. This would
mean that the nodes we have in memory are no longer valid. However, we can use the nodes in memory
to help find the new client rendered nodes. Once we do, we replay the events, set focus, etc.

##Freeze Strategies

Although we want to give the user some functionality before the client-side web app bootstrap is complete, 
it makes sense to freeze the UI when certain things happen on the page. For example, if the user fills in
a form and hits 'submit' we don't want the user to be able to do anything on the page until 
the client-side web app has the opportunity to process the form. Typically this type of thing includes an overlay
and/or a spinner. The idea behind the freeze strategy is to customize how an overlay and/or spinner
works and how it looks.

If you want to implement your own strategy you can pass the following object into the 'freeze' option:

```
{

    //TODO: complete example here
    
    prep: function (opts) {
    
    },
    
    cleanup: function () {
    
    }
}
```

You can also customize the style of the overlay and spinner by simply overriding/replacing the CSS file
that comes with this library in the dist folder.